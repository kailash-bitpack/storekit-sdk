/* tslint:disable */
/* eslint-disable */
/**
 * Meroku dApp store
 * Open API specs for Meroku DApp store. This documentation is the guide to Backend API. These APIs are required to build the frontend.  You can choose to build on top of this API or use the npm package available at [some link](https://www.example.com)  # Authentication  The endpoints themselves are public. The CORS policy restricts browser usage beyond `*.meroku.store`. This means that you can use these APIs in your backend services, but if called directly from frontend, it has to be hosted at *.meroku.store.  The `GET` calls are public without rate limiting.  The `POST`, `UPDATE`, `DELETE` calls ensure that only the dApp developer can make changes to their own dApp listing. This is done by sending the Github (user - server) token in these API calls. The mechanism to get the Github access tokens is up to the frontend to decide. They can for example create a Github App or use a service like Auth0.  ## Installing Github App for automated workflow Use the [/paths/app-ghID--installed/get](/paths/app-ghID--installed/get) to check if the required github app is installed on the account. If not, then get the URL from [/paths/app-installUrl/get](/paths/app-installUrl/get) and visit the URL to install the app.  In this server, you will be able to see your github details on the top left. You can use those details to enter values in the update calls.   # FAQs  1. I am getting a `400 Resource not accessible by integration` error on update calls. This can happen when the github token supplied does not have valid permissions. Ensure that you are not sending `org` param. Right now, the fork can only happen on individual and not at org level.   2. I am getting a `400 Not Found` error on update calls. Ensure that you are passing the correct github ID or the user who wants to make the update.  3. I am getting `400 Bad Credentials`. This can happen when the github token supplied is invalid. Ensure that you are sending the correct token. If the token is correct, then try signing out and signing in.
 *
 * OpenAPI spec version: 1.16
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BannedDAppsAddReq } from '../models';
import { Store } from '../models';
import { StoreKeyWithDevCreds } from '../models';
import { StoreWithDevCreds } from '../models';
import { UpdatedDappDetailsDappStoreReq } from '../models';
/**
 * StoreRegistryApi - axios parameter creator
 * @export
 */
export const StoreRegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adding a new store
         * @summary Add store
         * @param {StoreWithDevCreds} body Send the request with store schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStore: async (body: StoreWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addStore.');
            }
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the store from the resgitry
         * @summary Delete store
         * @param {StoreKeyWithDevCreds} body Send the request with  parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStore: async (body: StoreKeyWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteStore.');
            }
            const localVarPath = `/store/deleteStore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the particular store
         * @summary Get Store
         * @param {string} key unique id of a store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore: async (key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStore.');
            }
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This is to toggle the dApps from a banned list. If these dapps are not listed in the banned list, they will be added. If they are already added, they will be removed.  If the section by the key does not exist, will return a HTTP 400 error.
         * @summary Toggle dApps in banned list of store
         * @param {BannedDAppsAddReq} body Send the request with the parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBannedDApps: async (body: BannedDAppsAddReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putBannedDApps.');
            }
            const localVarPath = `/store/bannedDapps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If a dapp store want to change details of app(allowed only) for only their dapp store. Then they can change the values from here
         * @summary Add dapp details which want to be replace for dapp store
         * @param {UpdatedDappDetailsDappStoreReq} body Send the request with the parameters
         * @param {string} storeKey 
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDappDetailsDappStore: async (body: UpdatedDappDetailsDappStoreReq, storeKey: string, dappId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putDappDetailsDappStore.');
            }
            // verify required parameter 'storeKey' is not null or undefined
            if (storeKey === null || storeKey === undefined) {
                throw new RequiredError('storeKey','Required parameter storeKey was null or undefined when calling putDappDetailsDappStore.');
            }
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling putDappDetailsDappStore.');
            }
            const localVarPath = `/store/{storeKey}/dapp/{dappId}`
                .replace(`{${"storeKey"}}`, encodeURIComponent(String(storeKey)))
                .replace(`{${"dappId"}}`, encodeURIComponent(String(dappId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * For updating the existing store
         * @summary Update store
         * @param {StoreWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStore: async (body: StoreWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateStore.');
            }
            const localVarPath = `/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreRegistryApi - functional programming interface
 * @export
 */
export const StoreRegistryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adding a new store
         * @summary Add store
         * @param {StoreWithDevCreds} body Send the request with store schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStore(body: StoreWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).addStore(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the store from the resgitry
         * @summary Delete store
         * @param {StoreKeyWithDevCreds} body Send the request with  parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStore(body: StoreKeyWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).deleteStore(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the particular store
         * @summary Get Store
         * @param {string} key unique id of a store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStore(key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Store>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).getStore(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This is to toggle the dApps from a banned list. If these dapps are not listed in the banned list, they will be added. If they are already added, they will be removed.  If the section by the key does not exist, will return a HTTP 400 error.
         * @summary Toggle dApps in banned list of store
         * @param {BannedDAppsAddReq} body Send the request with the parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBannedDApps(body: BannedDAppsAddReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).putBannedDApps(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a dapp store want to change details of app(allowed only) for only their dapp store. Then they can change the values from here
         * @summary Add dapp details which want to be replace for dapp store
         * @param {UpdatedDappDetailsDappStoreReq} body Send the request with the parameters
         * @param {string} storeKey 
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDappDetailsDappStore(body: UpdatedDappDetailsDappStoreReq, storeKey: string, dappId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).putDappDetailsDappStore(body, storeKey, dappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * For updating the existing store
         * @summary Update store
         * @param {StoreWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStore(body: StoreWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await StoreRegistryApiAxiosParamCreator(configuration).updateStore(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StoreRegistryApi - factory interface
 * @export
 */
export const StoreRegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adding a new store
         * @summary Add store
         * @param {StoreWithDevCreds} body Send the request with store schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStore(body: StoreWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return StoreRegistryApiFp(configuration).addStore(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the store from the resgitry
         * @summary Delete store
         * @param {StoreKeyWithDevCreds} body Send the request with  parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStore(body: StoreKeyWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return StoreRegistryApiFp(configuration).deleteStore(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the particular store
         * @summary Get Store
         * @param {string} key unique id of a store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStore(key: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Store>> {
            return StoreRegistryApiFp(configuration).getStore(key, options).then((request) => request(axios, basePath));
        },
        /**
         * This is to toggle the dApps from a banned list. If these dapps are not listed in the banned list, they will be added. If they are already added, they will be removed.  If the section by the key does not exist, will return a HTTP 400 error.
         * @summary Toggle dApps in banned list of store
         * @param {BannedDAppsAddReq} body Send the request with the parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBannedDApps(body: BannedDAppsAddReq, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return StoreRegistryApiFp(configuration).putBannedDApps(body, options).then((request) => request(axios, basePath));
        },
        /**
         * If a dapp store want to change details of app(allowed only) for only their dapp store. Then they can change the values from here
         * @summary Add dapp details which want to be replace for dapp store
         * @param {UpdatedDappDetailsDappStoreReq} body Send the request with the parameters
         * @param {string} storeKey 
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDappDetailsDappStore(body: UpdatedDappDetailsDappStoreReq, storeKey: string, dappId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return StoreRegistryApiFp(configuration).putDappDetailsDappStore(body, storeKey, dappId, options).then((request) => request(axios, basePath));
        },
        /**
         * For updating the existing store
         * @summary Update store
         * @param {StoreWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStore(body: StoreWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return StoreRegistryApiFp(configuration).updateStore(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreRegistryApi - object-oriented interface
 * @export
 * @class StoreRegistryApi
 * @extends {BaseAPI}
 */
export class StoreRegistryApi extends BaseAPI {
    /**
     * Adding a new store
     * @summary Add store
     * @param {StoreWithDevCreds} body Send the request with store schema parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async addStore(body: StoreWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return StoreRegistryApiFp(this.configuration).addStore(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes the store from the resgitry
     * @summary Delete store
     * @param {StoreKeyWithDevCreds} body Send the request with  parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async deleteStore(body: StoreKeyWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return StoreRegistryApiFp(this.configuration).deleteStore(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the particular store
     * @summary Get Store
     * @param {string} key unique id of a store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async getStore(key: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Store>> {
        return StoreRegistryApiFp(this.configuration).getStore(key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is to toggle the dApps from a banned list. If these dapps are not listed in the banned list, they will be added. If they are already added, they will be removed.  If the section by the key does not exist, will return a HTTP 400 error.
     * @summary Toggle dApps in banned list of store
     * @param {BannedDAppsAddReq} body Send the request with the parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async putBannedDApps(body: BannedDAppsAddReq, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return StoreRegistryApiFp(this.configuration).putBannedDApps(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If a dapp store want to change details of app(allowed only) for only their dapp store. Then they can change the values from here
     * @summary Add dapp details which want to be replace for dapp store
     * @param {UpdatedDappDetailsDappStoreReq} body Send the request with the parameters
     * @param {string} storeKey 
     * @param {string} dappId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async putDappDetailsDappStore(body: UpdatedDappDetailsDappStoreReq, storeKey: string, dappId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return StoreRegistryApiFp(this.configuration).putDappDetailsDappStore(body, storeKey, dappId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * For updating the existing store
     * @summary Update store
     * @param {StoreWithDevCreds} body Send the request with the updated parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreRegistryApi
     */
    public async updateStore(body: StoreWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return StoreRegistryApiFp(this.configuration).updateStore(body, options).then((request) => request(this.axios, this.basePath));
    }
}
