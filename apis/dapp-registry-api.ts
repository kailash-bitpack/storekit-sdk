/* tslint:disable */
/* eslint-disable */
/**
 * Meroku dApp store
 * Open API specs for Meroku DApp store. This documentation is the guide to Backend API. These APIs are required to build the frontend.  You can choose to build on top of this API or use the npm package available at [some link](https://www.example.com)  # Authentication  The endpoints themselves are public. The CORS policy restricts browser usage beyond `*.meroku.store`. This means that you can use these APIs in your backend services, but if called directly from frontend, it has to be hosted at *.meroku.store.  The `GET` calls are public without rate limiting.  The `POST`, `UPDATE`, `DELETE` calls ensure that only the dApp developer can make changes to their own dApp listing. This is done by sending the Github (user - server) token in these API calls. The mechanism to get the Github access tokens is up to the frontend to decide. They can for example create a Github App or use a service like Auth0.  ## Installing Github App for automated workflow Use the [/paths/app-ghID--installed/get](/paths/app-ghID--installed/get) to check if the required github app is installed on the account. If not, then get the URL from [/paths/app-installUrl/get](/paths/app-installUrl/get) and visit the URL to install the app.  In this server, you will be able to see your github details on the top left. You can use those details to enter values in the update calls.   # FAQs  1. I am getting a `400 Resource not accessible by integration` error on update calls. This can happen when the github token supplied does not have valid permissions. Ensure that you are not sending `org` param. Right now, the fork can only happen on individual and not at org level.   2. I am getting a `400 Not Found` error on update calls. Ensure that you are passing the correct github ID or the user who wants to make the update.  3. I am getting `400 Bad Credentials`. This can happen when the github token supplied is invalid. Ensure that you are sending the correct token. If the token is correct, then try signing out and signing in.
 *
 * OpenAPI spec version: 1.16
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Dapp } from '../models';
import { DappIdWithDevCreds } from '../models';
import { DappWithDevCreds } from '../models';
import { InlineResponse200 } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse2004 } from '../models';
import { InlineResponse2005 } from '../models';
import { InlineResponse2006 } from '../models';
import { InlineResponse2007 } from '../models';
import { PreSignedUrlResponse } from '../models';
/**
 * DAppRegistryApi - axios parameter creator
 * @export
 */
export const DAppRegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adding new dApp to the store
         * @summary Add dApp
         * @param {DappWithDevCreds} body Send the request with dApp schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDApp: async (body: DappWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addDApp.');
            }
            const localVarPath = `/dapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Auto-Complete search
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DappAutocompleteGet: async (search: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'search' is not null or undefined
            if (search === null || search === undefined) {
                throw new RequiredError('search','Required parameter search was null or undefined when calling apiV1DappAutocompleteGet.');
            }
            const localVarPath = `/api/v1/dapp/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search DApp By owner Address
         * @param {string} ownerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DappSearchAddressOwnerAddressGet: async (ownerAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ownerAddress' is not null or undefined
            if (ownerAddress === null || ownerAddress === undefined) {
                throw new RequiredError('ownerAddress','Required parameter ownerAddress was null or undefined when calling apiV1DappSearchAddressOwnerAddressGet.');
            }
            const localVarPath = `/api/v1/dapp/search/address/{ownerAddress}`
                .replace(`{${"ownerAddress"}}`, encodeURIComponent(String(ownerAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DappSearchDappIdGet: async (dappId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling apiV1DappSearchDappIdGet.');
            }
            const localVarPath = `/api/v1/dapp/search/{dappId}`
                .replace(`{${"dappId"}}`, encodeURIComponent(String(dappId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploading dapp screenshots | logo | banner | dApp file to the servers
         * @summary Upload dApp files
         * @param {string} dappId 
         * @param {string} field 
         * @param {Array<Blob>} dAppFiles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dAppFilesForm: async (dappId: string, field: string, dAppFiles: Array<Blob>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling dAppFilesForm.');
            }
            // verify required parameter 'field' is not null or undefined
            if (field === null || field === undefined) {
                throw new RequiredError('field','Required parameter field was null or undefined when calling dAppFilesForm.');
            }
            // verify required parameter 'dAppFiles' is not null or undefined
            if (dAppFiles === null || dAppFiles === undefined) {
                throw new RequiredError('dAppFiles','Required parameter dAppFiles was null or undefined when calling dAppFilesForm.');
            }
            const localVarPath = `/dapp/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (dappId !== undefined) { 
                localVarFormParams.append('dappId', dappId as any);
            }

            if (field !== undefined) { 
                localVarFormParams.append('field', field as any);
            }
            if (dAppFiles) {
                dAppFiles.forEach((element) => {
                    localVarFormParams.append('dAppFiles', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get All category with subcategories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dappCategoriesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapp/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dappSearchByIdGet: async (dappId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling dappSearchByIdGet.');
            }
            const localVarPath = `/dapp/searchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dappId !== undefined) {
                localVarQueryParameter['dappId'] = dappId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the dApp from the store
         * @summary Delete dApp
         * @param {DappIdWithDevCreds} body Send the request with dApp parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDApp: async (body: DappIdWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteDApp.');
            }
            const localVarPath = `/dapp/deleteApp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Download URL
         * @param {string} dappId Dapp Id where upload will happen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBuildUrl: async (dappId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dappId' is not null or undefined
            if (dappId === null || dappId === undefined) {
                throw new RequiredError('dappId','Required parameter dappId was null or undefined when calling downloadBuildUrl.');
            }
            const localVarPath = `/dapp/{dappId}/build`
                .replace(`{${"dappId"}}`, encodeURIComponent(String(dappId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp.  This API call will get all the dApps or perform a text search.
         * @summary Get dApp
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {string} [language] DApp&#x27;s language
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [matureForAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<Array<string>>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {Array<Array<string>>} [subCategory] The sub-category in which dApps belong. Multiple sub-category are joined using OR operator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDApp: async (page?: number, limit?: number, search?: string, isListed?: boolean, chainId?: number, language?: string, availableOnPlatform?: Array<string>, matureForAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, categories?: Array<Array<string>>, orderBy?: string, subCategory?: Array<Array<string>>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (isListed !== undefined) {
                localVarQueryParameter['isListed'] = isListed;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (availableOnPlatform) {
                localVarQueryParameter['availableOnPlatform'] = availableOnPlatform;
            }

            if (matureForAudience !== undefined) {
                localVarQueryParameter['matureForAudience'] = matureForAudience;
            }

            if (minAge !== undefined) {
                localVarQueryParameter['minAge'] = minAge;
            }

            if (listedOnOrAfter !== undefined) {
                localVarQueryParameter['listedOnOrAfter'] = (listedOnOrAfter as any instanceof Date) ?
                    (listedOnOrAfter as any).toISOString().substr(0,10) :
                    listedOnOrAfter;
            }

            if (listedOnOrBefore !== undefined) {
                localVarQueryParameter['listedOnOrBefore'] = (listedOnOrBefore as any instanceof Date) ?
                    (listedOnOrBefore as any).toISOString().substr(0,10) :
                    listedOnOrBefore;
            }

            if (allowedInCountries) {
                localVarQueryParameter['allowedInCountries'] = allowedInCountries;
            }

            if (blockedInCountries) {
                localVarQueryParameter['blockedInCountries'] = blockedInCountries;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (subCategory) {
                localVarQueryParameter['subCategory'] = subCategory;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp. This API call will get all the dApps or perform a text search.
         * @summary Search Dapps
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {Array<string>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {Array<string>} [subCategories] The sub-categories in which dApps belong. Multiple sub-categories are joined using OR operator.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {string} [language] DApp&#x27;s language
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [isForMatureAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDapps: async (page?: number, limit?: number, orderBy?: string, search?: string, categories?: Array<string>, subCategories?: Array<string>, isListed?: boolean, language?: string, chainId?: number, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, availableOnPlatform?: Array<string>, isForMatureAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dapp/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (subCategories) {
                localVarQueryParameter['subCategories'] = subCategories;
            }

            if (isListed !== undefined) {
                localVarQueryParameter['isListed'] = isListed;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (allowedInCountries) {
                localVarQueryParameter['allowedInCountries'] = allowedInCountries;
            }

            if (blockedInCountries) {
                localVarQueryParameter['blockedInCountries'] = blockedInCountries;
            }

            if (availableOnPlatform) {
                localVarQueryParameter['availableOnPlatform'] = availableOnPlatform;
            }

            if (isForMatureAudience !== undefined) {
                localVarQueryParameter['isForMatureAudience'] = isForMatureAudience;
            }

            if (minAge !== undefined) {
                localVarQueryParameter['minAge'] = minAge;
            }

            if (listedOnOrAfter !== undefined) {
                localVarQueryParameter['listedOnOrAfter'] = (listedOnOrAfter as any instanceof Date) ?
                    (listedOnOrAfter as any).toISOString().substr(0,10) :
                    listedOnOrAfter;
            }

            if (listedOnOrBefore !== undefined) {
                localVarQueryParameter['listedOnOrBefore'] = (listedOnOrBefore as any instanceof Date) ?
                    (listedOnOrBefore as any).toISOString().substr(0,10) :
                    listedOnOrBefore;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * For updating the existing dApp
         * @summary Update dApp
         * @param {DappWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDApp: async (body: DappWithDevCreds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateDApp.');
            }
            const localVarPath = `/dapp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DAppRegistryApi - functional programming interface
 * @export
 */
export const DAppRegistryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adding new dApp to the store
         * @summary Add dApp
         * @param {DappWithDevCreds} body Send the request with dApp schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDApp(body: DappWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).addDApp(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Auto-Complete search
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappAutocompleteGet(search: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2007>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).apiV1DappAutocompleteGet(search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search DApp By owner Address
         * @param {string} ownerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappSearchAddressOwnerAddressGet(ownerAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).apiV1DappSearchAddressOwnerAddressGet(ownerAddress, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappSearchDappIdGet(dappId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).apiV1DappSearchDappIdGet(dappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploading dapp screenshots | logo | banner | dApp file to the servers
         * @summary Upload dApp files
         * @param {string} dappId 
         * @param {string} field 
         * @param {Array<Blob>} dAppFiles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dAppFilesForm(dappId: string, field: string, dAppFiles: Array<Blob>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2003>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).dAppFilesForm(dappId, field, dAppFiles, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get All category with subcategories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dappCategoriesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2004>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).dappCategoriesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dappSearchByIdGet(dappId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Dapp>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).dappSearchByIdGet(dappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes the dApp from the store
         * @summary Delete dApp
         * @param {DappIdWithDevCreds} body Send the request with dApp parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDApp(body: DappIdWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).deleteDApp(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Build Download URL
         * @param {string} dappId Dapp Id where upload will happen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBuildUrl(dappId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PreSignedUrlResponse>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).downloadBuildUrl(dappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp.  This API call will get all the dApps or perform a text search.
         * @summary Get dApp
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {string} [language] DApp&#x27;s language
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [matureForAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<Array<string>>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {Array<Array<string>>} [subCategory] The sub-category in which dApps belong. Multiple sub-category are joined using OR operator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDApp(page?: number, limit?: number, search?: string, isListed?: boolean, chainId?: number, language?: string, availableOnPlatform?: Array<string>, matureForAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, categories?: Array<Array<string>>, orderBy?: string, subCategory?: Array<Array<string>>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).getDApp(page, limit, search, isListed, chainId, language, availableOnPlatform, matureForAudience, minAge, listedOnOrAfter, listedOnOrBefore, allowedInCountries, blockedInCountries, categories, orderBy, subCategory, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp. This API call will get all the dApps or perform a text search.
         * @summary Search Dapps
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {Array<string>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {Array<string>} [subCategories] The sub-categories in which dApps belong. Multiple sub-categories are joined using OR operator.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {string} [language] DApp&#x27;s language
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [isForMatureAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDapps(page?: number, limit?: number, orderBy?: string, search?: string, categories?: Array<string>, subCategories?: Array<string>, isListed?: boolean, language?: string, chainId?: number, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, availableOnPlatform?: Array<string>, isForMatureAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2005>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).searchDapps(page, limit, orderBy, search, categories, subCategories, isListed, language, chainId, allowedInCountries, blockedInCountries, availableOnPlatform, isForMatureAudience, minAge, listedOnOrAfter, listedOnOrBefore, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * For updating the existing dApp
         * @summary Update dApp
         * @param {DappWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDApp(body: DappWithDevCreds, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await DAppRegistryApiAxiosParamCreator(configuration).updateDApp(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DAppRegistryApi - factory interface
 * @export
 */
export const DAppRegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adding new dApp to the store
         * @summary Add dApp
         * @param {DappWithDevCreds} body Send the request with dApp schema parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDApp(body: DappWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return DAppRegistryApiFp(configuration).addDApp(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Auto-Complete search
         * @param {string} search 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappAutocompleteGet(search: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2007>> {
            return DAppRegistryApiFp(configuration).apiV1DappAutocompleteGet(search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search DApp By owner Address
         * @param {string} ownerAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappSearchAddressOwnerAddressGet(ownerAddress: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2006>> {
            return DAppRegistryApiFp(configuration).apiV1DappSearchAddressOwnerAddressGet(ownerAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DappSearchDappIdGet(dappId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2006>> {
            return DAppRegistryApiFp(configuration).apiV1DappSearchDappIdGet(dappId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploading dapp screenshots | logo | banner | dApp file to the servers
         * @summary Upload dApp files
         * @param {string} dappId 
         * @param {string} field 
         * @param {Array<Blob>} dAppFiles 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dAppFilesForm(dappId: string, field: string, dAppFiles: Array<Blob>, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2003>> {
            return DAppRegistryApiFp(configuration).dAppFilesForm(dappId, field, dAppFiles, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get All category with subcategories.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dappCategoriesGet(options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2004>> {
            return DAppRegistryApiFp(configuration).dappCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search DApp By Dapp Id
         * @param {string} dappId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dappSearchByIdGet(dappId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Dapp>> {
            return DAppRegistryApiFp(configuration).dappSearchByIdGet(dappId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the dApp from the store
         * @summary Delete dApp
         * @param {DappIdWithDevCreds} body Send the request with dApp parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDApp(body: DappIdWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return DAppRegistryApiFp(configuration).deleteDApp(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Download URL
         * @param {string} dappId Dapp Id where upload will happen
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadBuildUrl(dappId: string, options?: AxiosRequestConfig): Promise<AxiosResponse<PreSignedUrlResponse>> {
            return DAppRegistryApiFp(configuration).downloadBuildUrl(dappId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp.  This API call will get all the dApps or perform a text search.
         * @summary Get dApp
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {string} [language] DApp&#x27;s language
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [matureForAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<Array<string>>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {Array<Array<string>>} [subCategory] The sub-category in which dApps belong. Multiple sub-category are joined using OR operator.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDApp(page?: number, limit?: number, search?: string, isListed?: boolean, chainId?: number, language?: string, availableOnPlatform?: Array<string>, matureForAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, categories?: Array<Array<string>>, orderBy?: string, subCategory?: Array<Array<string>>, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200>> {
            return DAppRegistryApiFp(configuration).getDApp(page, limit, search, isListed, chainId, language, availableOnPlatform, matureForAudience, minAge, listedOnOrAfter, listedOnOrBefore, allowedInCountries, blockedInCountries, categories, orderBy, subCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp. This API call will get all the dApps or perform a text search.
         * @summary Search Dapps
         * @param {number} [page] Current page
         * @param {number} [limit] Page size
         * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
         * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
         * @param {Array<string>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
         * @param {Array<string>} [subCategories] The sub-categories in which dApps belong. Multiple sub-categories are joined using OR operator.
         * @param {boolean} [isListed] DApp is listed or not
         * @param {string} [language] DApp&#x27;s language
         * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
         * @param {Array<string>} [allowedInCountries] dApp allowed countries
         * @param {Array<string>} [blockedInCountries] dApp blocked countries
         * @param {Array<string>} [availableOnPlatform] DApp is listed or not
         * @param {boolean} [isForMatureAudience] Mentions if the app is for all ages or only mature audience
         * @param {number} [minAge] Minimum age
         * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
         * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDapps(page?: number, limit?: number, orderBy?: string, search?: string, categories?: Array<string>, subCategories?: Array<string>, isListed?: boolean, language?: string, chainId?: number, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, availableOnPlatform?: Array<string>, isForMatureAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2005>> {
            return DAppRegistryApiFp(configuration).searchDapps(page, limit, orderBy, search, categories, subCategories, isListed, language, chainId, allowedInCountries, blockedInCountries, availableOnPlatform, isForMatureAudience, minAge, listedOnOrAfter, listedOnOrBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * For updating the existing dApp
         * @summary Update dApp
         * @param {DappWithDevCreds} body Send the request with the updated parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDApp(body: DappWithDevCreds, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return DAppRegistryApiFp(configuration).updateDApp(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DAppRegistryApi - object-oriented interface
 * @export
 * @class DAppRegistryApi
 * @extends {BaseAPI}
 */
export class DAppRegistryApi extends BaseAPI {
    /**
     * Adding new dApp to the store
     * @summary Add dApp
     * @param {DappWithDevCreds} body Send the request with dApp schema parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async addDApp(body: DappWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return DAppRegistryApiFp(this.configuration).addDApp(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Auto-Complete search
     * @param {string} search 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async apiV1DappAutocompleteGet(search: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2007>> {
        return DAppRegistryApiFp(this.configuration).apiV1DappAutocompleteGet(search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Search DApp By owner Address
     * @param {string} ownerAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async apiV1DappSearchAddressOwnerAddressGet(ownerAddress: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2006>> {
        return DAppRegistryApiFp(this.configuration).apiV1DappSearchAddressOwnerAddressGet(ownerAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Search DApp By Dapp Id
     * @param {string} dappId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async apiV1DappSearchDappIdGet(dappId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2006>> {
        return DAppRegistryApiFp(this.configuration).apiV1DappSearchDappIdGet(dappId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploading dapp screenshots | logo | banner | dApp file to the servers
     * @summary Upload dApp files
     * @param {string} dappId 
     * @param {string} field 
     * @param {Array<Blob>} dAppFiles 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async dAppFilesForm(dappId: string, field: string, dAppFiles: Array<Blob>, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2003>> {
        return DAppRegistryApiFp(this.configuration).dAppFilesForm(dappId, field, dAppFiles, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get All category with subcategories.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async dappCategoriesGet(options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2004>> {
        return DAppRegistryApiFp(this.configuration).dappCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Search DApp By Dapp Id
     * @param {string} dappId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async dappSearchByIdGet(dappId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Dapp>> {
        return DAppRegistryApiFp(this.configuration).dappSearchByIdGet(dappId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes the dApp from the store
     * @summary Delete dApp
     * @param {DappIdWithDevCreds} body Send the request with dApp parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async deleteDApp(body: DappIdWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return DAppRegistryApiFp(this.configuration).deleteDApp(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Build Download URL
     * @param {string} dappId Dapp Id where upload will happen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async downloadBuildUrl(dappId: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<PreSignedUrlResponse>> {
        return DAppRegistryApiFp(this.configuration).downloadBuildUrl(dappId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp.  This API call will get all the dApps or perform a text search.
     * @summary Get dApp
     * @param {number} [page] Current page
     * @param {number} [limit] Page size
     * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
     * @param {boolean} [isListed] DApp is listed or not
     * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
     * @param {string} [language] DApp&#x27;s language
     * @param {Array<string>} [availableOnPlatform] DApp is listed or not
     * @param {boolean} [matureForAudience] Mentions if the app is for all ages or only mature audience
     * @param {number} [minAge] Minimum age
     * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
     * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
     * @param {Array<string>} [allowedInCountries] dApp allowed countries
     * @param {Array<string>} [blockedInCountries] dApp blocked countries
     * @param {Array<Array<string>>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
     * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
     * @param {Array<Array<string>>} [subCategory] The sub-category in which dApps belong. Multiple sub-category are joined using OR operator.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async getDApp(page?: number, limit?: number, search?: string, isListed?: boolean, chainId?: number, language?: string, availableOnPlatform?: Array<string>, matureForAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, categories?: Array<Array<string>>, orderBy?: string, subCategory?: Array<Array<string>>, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200>> {
        return DAppRegistryApiFp(this.configuration).getDApp(page, limit, search, isListed, chainId, language, availableOnPlatform, matureForAudience, minAge, listedOnOrAfter, listedOnOrBefore, allowedInCountries, blockedInCountries, categories, orderBy, subCategory, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all dApps or search by a keyword. Optionally, filter on specific attributes of the dApp. This API call will get all the dApps or perform a text search.
     * @summary Search Dapps
     * @param {number} [page] Current page
     * @param {number} [limit] Page size
     * @param {string} [orderBy] Want to get dapp by order(asc, desc) by one or more params.
     * @param {string} [search] A string to be used for search. The search happens on the &#x60;name&#x60; and &#x60;tags&#x60; fields of the dApp. If this is not present, all dApps are returned.
     * @param {Array<string>} [categories] The categories in which dApps belong. Multiple categories are joined using OR operator.
     * @param {Array<string>} [subCategories] The sub-categories in which dApps belong. Multiple sub-categories are joined using OR operator.
     * @param {boolean} [isListed] DApp is listed or not
     * @param {string} [language] DApp&#x27;s language
     * @param {number} [chainId] DApp supported chainId&#x27;s. Only dApps belonging to this chainID will be returned.
     * @param {Array<string>} [allowedInCountries] dApp allowed countries
     * @param {Array<string>} [blockedInCountries] dApp blocked countries
     * @param {Array<string>} [availableOnPlatform] DApp is listed or not
     * @param {boolean} [isForMatureAudience] Mentions if the app is for all ages or only mature audience
     * @param {number} [minAge] Minimum age
     * @param {string} [listedOnOrAfter] The date dApp was listed on or after. Date should be in ISO format.
     * @param {string} [listedOnOrBefore] The date dApp was listed on or before. Date should be in ISO format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async searchDapps(page?: number, limit?: number, orderBy?: string, search?: string, categories?: Array<string>, subCategories?: Array<string>, isListed?: boolean, language?: string, chainId?: number, allowedInCountries?: Array<string>, blockedInCountries?: Array<string>, availableOnPlatform?: Array<string>, isForMatureAudience?: boolean, minAge?: number, listedOnOrAfter?: string, listedOnOrBefore?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2005>> {
        return DAppRegistryApiFp(this.configuration).searchDapps(page, limit, orderBy, search, categories, subCategories, isListed, language, chainId, allowedInCountries, blockedInCountries, availableOnPlatform, isForMatureAudience, minAge, listedOnOrAfter, listedOnOrBefore, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * For updating the existing dApp
     * @summary Update dApp
     * @param {DappWithDevCreds} body Send the request with the updated parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DAppRegistryApi
     */
    public async updateDApp(body: DappWithDevCreds, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return DAppRegistryApiFp(this.configuration).updateDApp(body, options).then((request) => request(this.axios, this.basePath));
    }
}
